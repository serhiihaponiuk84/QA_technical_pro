
// Question 1. Який оператор порівняння використовує switch?

// Question 2. Яке ключове слово зупиняє процес порівняння в switch?

// Question 3. Чи буде показано console log?
if ("0") {
    console.log('Привіт');
}

// Question 4. Яке значення у с?
let e = 2; let b = 1; let c;
console.log(c);

// Question 5. Який буде результат цих виразів?
console.log(5 > 4)
console.log("ананас" > "яблуко")
console.log("2" > "12")
console.log(undefined == null)
console.log(undefined === null )

// Question 6. Які кінцеві значення всіх змінних a та x після виконання коду нижче?
let a = 2;
let x = 1 + (a * 2);
//let x = 1 + (a *= 2);
console.log("a = " + a)
console.log("x = " + x)

// Question 7. Які кінцеві значення всіх змінних q, r, w та d після виконання коду нижче?
let q = 1;
let r = 1;
let w = ++q;
let d = r++;

console.log("q = " + q)
console.log("r = " + r)
console.log("w = " + w)
console.log("d = " + d)


// Question 8. Приклад завдання додому. Які результати цих виразів?
console.log("" + 1 + 0)
console.log("" - 1 + 0)
console.log("" + 1 - 2)
console.log(true + false)
console.log(6 / "3")
console.log("2" * "3")
console.log(4 + 5 + "px")
console.log("px" + 4 + 5 )
console.log("$" + 4 + 5)
console.log("4" - 2)
console.log("4px" - 2)
console.log("  -9  " + 5)
console.log("  -9  " - 5)
console.log(null + 1)
console.log(undefined + 1)
console.log(" \t \n" - 2)




//// LECTURE


/* -----Цикли-----
 Цикл – це спосіб повторити один і той же код кілька разів.

 Кожне повторення в циклі називається ітерацією.
 Ітерація - це один прохід або повторення циклу, під час якого виконуються певні інструкції,
 і потім перевіряється умова, щоб вирішити, чи треба продовжувати виконання циклу чи завершити його.

 Цикли дуже часто використовуються при побудові алгоритму, оскільки певний набір
інструкцій часто повторюється неодноразово. Наприклад, потрібно обробити список
користувачів і вивести всіх, хто має права адміна, пройтися за набором цілих значень і
знайти найбільше значення, і т. д.
 */

/* --- while...do - "спочатку думаємо - потім робимо", тобто це – цикл із передумовою.
Виконується, поки умова істинна. Умову перевіряють  перед виконанням тіла.

Доки умова є вірною, виконується код із тіла циклу.


while(УМОВА)
{
  ТІЛО ІТЕРАЦІЇ
}
*/

/* let i = 0;
while (i < 10) {
    console.log('i = ' + i);
} */

//Цикл while може закінчитися, так і не розпочавшись
while (false) {
    console.log('А я все одно щось зроблю ?');
}
console.log('Кінець завдання');

//А може й затягнутися (не треба так робити)
while (true) {
    console.log('А я все одно щось зроблю ');
    break;
}
console.log('Кінець завдання');

// Наприклад, коротший спосіб написання while (i != 0) відповідає while (i):
/* let i = 10;
while (i) { // коли i буде 0, умова стане невірною, і цикл зупиниться
    console.log(i);
    i--;
} */

// Якщо тіло цикла має тільки одну операцію, ми можемо опустити фігурні дужки {…}:
/* let i = 10;
while (i) console.log(i--); */

/*---- do...while - "спочатку робимо, потім думаємо", цикл із постумовою.
Виконується, поки умова істинна. Умову перевіряють після тіла.

цикл подібний до циклу "while", але з однією важливою відмінністю:
цикл спочатку виконує тіло, а потім перевіряє умову, і поки умова є true, цикл виконується знову і знову.

Синтаксис:
do {
  // Код, який виконується принаймні один раз
} while (умова);

*/

var i = 0;
do {
    i += 2;
    console.log("i = " + i);
} while (i < 5);
console.log("Після закінчення циклу i = " + i);

// do...while обов'язково відпрацює хоча б раз!

do {
    console.log("А я все одно щось зроблю");
} while (false);


//-------------------------------------------------------------------------------------------------------------------------
/* ----- Цикл For. ---  цикл із лічильником. Цей цикл містить лічильник ітерацій циклу з певним кроком,
який змінює значення до заданого кінцевого значення

це одна з найбільш розповсюджених конструкцій для управління потоком виконання коду.
 Він використовується для повторення виконання блоку коду певну кількість разів, як правило,
 з використанням лічильника.

 Основна синтаксична структура циклу "for" виглядає так:

 for (ініціалізація; умова; крок) {
  // Код, який виконується поки умова істинна
};

*/

for (var i = 0; i < 9; i++) {   // початок - var i = 0. Виконується один раз, при вході в цикл.
                                // умова - i < 9.Перевіряється перед кожною ітерацією циклу. Якщо умова невірна, цикл зупиняєтья.
                                // тіло - console.log('лічильник циклу i= ' + i);. Виконується знову і знову, поки умова є правдивою (true).
                                // крок - i++. Виконується після тіла на кожній ітерації, але перед перевіркою умови.
    console.log('лічильник циклу i = ' + i);
}
console.log("Після закінчення циклу i = " + i);

/* Будь-яку частину for можна пропустити.

 Приклад без початку */
/* let i = 0; // ми вже маємо оголошену змінну і присвоєне значення
for (; i <= 4; i++) { // немає необхідності в "початку"
    console.log(i);
} */

// Приклад без кроку. Це робить цикл ідентичним до while (i < 5).
/* let i = 0;
for (; i < 5;) {
    console.log( i++ );
} */

/*Можна взагалі забрати все, отримавши нескінченний цикл.

Зауважте, що ці двокрапки ; повинні бути, інакше виникне синтаксична помилка. */

for (; ;) {
    // буде вічно повторюватися
    console.log("hi");
}

/*--- break, continue --- ручне керування циклом

Зазвичай, цикл завершується, коли умова стає false.

Щоб завершити виконання циклу до того, як виконаються всі його ітерації відповідно до
умови, можна використовувати ключове слово break. Наприклад, якщо цикл за
початковими налаштуваннями повинен виконати 1000 ітерацій у пошуках деякого
значення, такий цикл є сенс зупинити до завершення всіх ітерацій, якщо шукане
значення було знайдено.

Якщо під час виконання циклу потрібно пропустити тіло циклу та перейти до наступної
ітерації, використовується інструкція continue. Після неї виконання переходить до умови
циклу і якщо умова істинна, то починається наступна ітерація циклу. Наприклад, потрібно
обробити набір даних та вивести на екран певні значення, а невідповідні значення з
набору – пропустити. Щоб пропустити непотрібне значення та перейти до наступного,
можна використовувати continue
*/

var i = 0;
for (; ;) {
    if (i === 3) {
        console.log("Дійшли до 3");
        break;
    }
    console.log(i);
    i++;
}
console.log("Після закінчення циклу i = " + i);

/* --- continue  --— це “полегшена версія” break. Вона не зупиняє весь цикл.
Натомість, вона зупиняє поточну ітерацію і починає виконання циклу спочатку з наступної ітерації (якщо умова циклу досі вірна).
Її зручно використовувати коли закінчили з поточною ітерацією і хочемо продовжити з наступної.

Для парних значень змінної i, директива continue зупиняє виконання тіла циклу
і передає контроль наступній ітерації в for (в цьому випадку це буде наступне число).
Таким чином функція alert викликається лише для непарних значень змінної i.

@@@ https://www.tiktok.com/@devslopes/video/7319731188652854571 @@@ */


//погане рішення
for (let x = 0; x < 10; x++) {
    if (x % 2) console.log('тільки парні: х = ' + x);
}
console.log("Як це ще може виглядати");


//давайте пофіксимо
for (let x = 0; x < 10; x++) {
    if (x % 2) continue;   // якщо умова справджується, тоді пропускаємо решту тіла циклу і починаємо з наступної ітерації
    console.log('тільки парні: х = ' + x);
}
console.log("Як це ще може виглядати");

for (let x = 0; x < 10; x++) {
    if (x % 2) break;
    console.log('тільки парні: х = ' + x);
}
console.log("Як це ще може виглядати");



// Уявімо що ми хочемо створити таблицю множення на 5
let number = 5;
for (let i = 1; i <= 9; i++) {
    console.log("Результат множення " + number + " * " + i + " = " + number * i);
}

// Тепер я хочу зробити всю таблицю множення
for (let i = 1; i <= 9; i++) { //1 2
    for (let j = 1; j <= 9; j++) { //1 2 3
        console.log("Результат множення " + i + " * " + j + " = " + i * j);
    }
    console.log("----------------------------")
}

// Тобто ми можемо використовувати один  for, до іншого!

// А якщо я хочу множити тільки парне значення
for (let i = 1; i <= 9; i++) {
    if (i % 2) continue;
    for (let j = 1; j <= 9; j++) {
        console.log("Результат множення " + i + " * " + j + " = " + i * j);
    }
    console.log("----------------------------")
}

/*--- Мітки для циклів ---
Мітки (labels) для циклів в JavaScript - це іменовані мітки,
які можна використовувати для змінення поведінки циклів.
Вони дозволяють виконувати розриви і переходи до певних міток всередині вкладених циклів.

Мітки - це потужний механізм управління потоком виконання коду,
але їх використання може бути складним і призводити до складного коду,
тому слід використовувати їх з розсудливістю.
*/

label: for (let i = 1; i <= 9; i++) {
    for (let j = 1; j <= 9; j++) {
        if (j === 5) {
            console.log("----------------------------")
            continue label;
        }
        console.log("Результат множення " + i + " * " + j + " = " + i * j);
    }
}

//-------------------------------------------------------------------------------------------------------------------------
/**
 Functions (Функції) - це блоки коду, які можна викликати з будь-якого місця у програмі.
 Вони дозволяють згрупувати певний фрагмент коду і використовувати його в багатьох місцях
 без необхідності повторювати сам код.

 У JavaScript є кілька способів визначення функцій:
 - Function Declaration
 - Function Expression
 - Arrow Functions  */

// --- Класичний випадок - Function Declaration---

function test() {   //Оголошення функції
    console.log("Привіт із функції!");  //Тіло функції
}

test(); // виклик функції
test(); // виклик функції
test(); // виклик функції

//Додамо щось цікавіше ніж console.log. Давайте розрахуємо площу квадрату

function squareAreaCalculation() {
    let qwerty = 4;
    console.log(qwerty * qwerty);
}
squareAreaCalculation();

console.log(qwerty); // qwerty  - прихована


//Функція – єдиний спосіб створити локальну область видимості

var ext = "Зовнішня змінна";

function test() {
    var inner = "Тільки для внутрішнього користування";
    console.log('Бачу: ext = ' + ext);
    console.log('Бачу: inner = ' + inner);
}
test();

console.log('А тепер – зовні:')
console.log('Бачу: ext = ' + ext);
console.log('Бачу: inner = ' + inner);

/* --- Function Expression (функціональній вираз). Він дозволяє створювати функцію всередині будь-якого виразу.
Зауважте, після ключового слова function немає назви функції. Для функціональних виразів це допустимо. */

let squareArea = function () {
    let a = 2;
    console.log(a * a);
}
squareArea();

// Function Expression корисно використовувати коли ми хочемо в змінній зберігати різні функції
let autoBrand = "ТАВРІЯ";
let accelerateСar;
switch (autoBrand) {
    case "Audi":
        accelerateСar = function () {
            let audiSpeedIndex = 100;
            console.log("Розганяємо авто до 150км: " + audiSpeedIndex * 1.5);
        }
        break;
    case "ТАВРІЯ":
        accelerateСar = function () {
            let audiSpeedIndex = 0;
            console.log("Розганяємо авто до 150км")
            for (let i = 0; i < 60; i += 10) {
                audiSpeedIndex += i;
                console.log(audiSpeedIndex);
            }
        }
        break;
}
accelerateСar();

// Це все чудово, але є певні загальні рекомендації що і як повинна містити функція.
function squareAreaCalculation() {
    let a = prompt("Ввести сторону квадрату"); // Нечиста функція через побічний ефект
    let result = a * a;
    console.log(result);  // Нечиста функція через побічний ефект
}

// Тепер трохи краще, але...
//let a = prompt("Ввести сторону квадрату");
let a = 6;

function squareAreaCalculation() {
    let result = a * a;
}

console.log(result); // Але ми тут не бачимо нашу змінну.

/* --- Поняття return ----
В якості результату, функція може повертати назад значення в код, який викликав цю функцію.

@ @ @ https://www.tiktok.com/@devslopes/video/7296892487656836398 @ @ @
*/

// Розглянемо що повертає функція за замовчуванням
let c = 5;
function squareAreaCalculation() {
    let result = c * c;
}
console.log(squareAreaCalculation())

function squareAreaCalculation() {
    let result = c * c; // Але все одно погано що ми маємо залежність через використання зовнішньої змінної:
    return result;
    // return result = c * c;
}
var result = squareAreaCalculation();
console.log(result);

/* Директива return може бути в будь-якому місці функції.
 Коли виконання досягає цієї директиви, функція зупиняється, і в код, який викликав цю функцію,
 повертається значення (в прикладі вище, це значення присвоюється змінній result)

 return - це безумовний вихід із функції */

/* let c = 5;
function squareAreaCalculation() {
    let result = c * c; // Але все одно погано що ми маємо залежність через використання зовнішньої змінної:
    return result;
    console.log("After return");
}
let result = squareAreaCalculation();
console.log(result); */

//В одній функції може бути декілька директив return. Наприклад:
function checkAge() {
    let age = 10;
    if (age >= 18) {
        return console.log('У вас є дозвіл');
    } else {
        return console.log('У вас є дозвіл ваших батьків?');
    }
}
checkAge();

//Можна використовувати return без значення. Це призведе до негайного виходу з функції.
function showMovie() {
    let age = 10;
    if (age <= 18) {
        return;
    }
    console.log("Показуємо фільм");  //В коді вище, якщо if поверне false, тоді функція showMovie не дійде до виконання console.log.
}
showMovie()

/* --- Найменування функції---
Функції виконують дії. Тому в їхніх іменах зазвичай використовують дієслова.
Ім’я повинне бути лаконічним, повинне якнайточніше описувати, що робить функція,
щоб кожен хто читає код зміг зрозуміти, що саме робить функція.

Поширена практика розпочинати ім’я функції зі словесного префіксу, який описує дію.
В команді має бути домовленість щодо значення префіксів.

Наприклад, функції, які починаються з префіксу "show" зазвичай щось показують.

Функції, які починаються з …
- "get…" – повертають значення,
- "calc…" – щось обчислюють,
- "create…" – щось створюють,
- "check…" – щось перевіряють і повертають булеве значення.

Ось приклади таких імен:
showMessage(..)     // показує повідомлення
getAge(..)          // повертає вік (якось його отримує або обчислює)
calcSum(..)         // обчислює суму і повертає результат
createForm(..)      // створює форму (і зазвичай її повертає)
checkPermission(..) // перевіряє доступ, повертає true/false

--- Для чого використовують функції? ---
Одна функція – одна дія
Функція повинна робити саме те, що написано в її імені, не більше.
Дві незалежні дії зазвичай заслуговують двох функцій, навіть якщо вони зазвичай викликаються разом
(у цьому випадку ми можемо створити 3-ю функцію, яка викликає ці дві).

Ось декілька прикладів, які порушують це правило:
- getAge – функція викликає alert з віком (а повинна лише отримувати вік).
- createForm – функція змінює документ, додаючи форму до неї (а повинна лише створити форму і її вернути).
- checkPermission – функція відображає повідомлення доступ надано/відхилено (а повинна лише повертати результат true/false).

Ці приклади передбачають загальне значення префіксів. Ви та ваша команда можете вільно домовлятися про інші значення, але зазвичай вони не сильно відрізняються.
У будь-якому випадку ви повинні чітко розуміти, що означає префікс, що може робити префіксна функція, а що ні. Усі функції з однаковими префіксами повинні підкорятися правилам.
І команда повинна ділитися знаннями.
*/

/* --- Передача значень у функцію ---
Ми можемо передати в функцію довільні дані використовуючи параметри.
*/


function squareAreaCalculation(side) {
    return side * side;
}

let result = squareAreaCalculation(5);
console.log(result);


// А що буде якщо я не передам нічого
/* function squareAreaCalculation(side) {
    console.log(side);
    return side * side;
}

let result = squareAreaCalculation();

console.log(result); */

// Параметрів можна вказувати скільки завгодно
function hello(name, surname, age) {
    console.log("Hello " + name + " " + surname + ", your age is " + age);
}
hello('Dmitro', 'Tuchina', 12);

//А можна якось встановити параметри за замовчуванням, або що робити якщо нам нічого не передали
function hello(name, surname) {
    let greet = 'Hello ';
    name = name || 'John Snow';
    if (surname)
        greet += name + ' ' + surname;
    else
        greet += name;
    return greet;
}
console.log(hello());
console.log(hello('Volodimir'));
console.log(hello('Dmitro', 'Sirko'));

// Інший варіант як можна задати значення за замовчуванням
function hello(name = 'default123456') {
    return 'Hello ' + name;
}
console.log(hello());
console.log(hello('Volodimir'));


/* Функціональний Вираз проти Оголошення Функції

Функціональний Вираз буде створено тільки тоді, коли до нього дійде виконання
і тільки після цього він може бути використаний.
Синтаксис Оголошення Функції дозволяє викликати функцію раніше, ніж вона були визначена в коді
Наприклад, глобальне Оголошення Функції буде доступним з будь-якого місця в скрипті.

Така поведінка спричинена особливостями внутрішніх алгоритмів.
Коли JavaScript готується до виконання скрипта,  він спочатку шукає всі глобальні Оголошення Функцій і на їх основі створює функції.
Цей процес можна вважати “фазою ініціалізації”.
Після того, як всі Оголошення Функцій були оброблені, рушій починає виконання коду.
*/

//Це, наприклад, буде працювати:
sayHi("Foxy");

function sayHi(name) {
    console.log(`Привіт, ` + name);
}

//…З Функціональним Виразом це не спрацювало б:
sayHi("Foxy");

let sayHi = function (name) {
    console.log(`Привіт, ` + name);
};

/* --- Стрілкові функції ---
Це так звані “стрілкові функції”, а виглядають вони ось так:

let func = (arg1, arg2, ..., argN) => expression;

Цей код створить функцію func з аргументами arg1..argN,
що обчислює expression з правого боку (використовуючи ці аргументи) та повертає його результат.
*/

let sum = (a, b) => a + b; //Як ви бачите, (a, b) => a + b означає функцію, яка приймає два аргументи a і b. Після запуску, вона виконає вираз a + b і поверне результат.
console.log(sum(5, 9));

/* Ця стрілкова функція — це коротша форма для:

let sum = function(a, b) {
  return a + b;
};

function sum(a, b) {
  return a + b;
};
*/

// Стрілкові функції можна використовувати тим самим способом, що й Функціональні Вирази.
let age = 22;

let welcome = (age < 18) ?
    () => console.log('Привіт') :
    () => console.log("Вітання!");
welcome();


// Якщо функція має лише один аргумент, тоді дужки навколо параметрів можна опускати, що дозволить записати її ще коротше
let multiply = n => n * 4; // те ж саме, що і: let double = function(n) { return n * 2 }
console.log(multiply(5));

//Якщо аргументів немає, то дужки порожні, але вони повинні бути:
let sayHi = () => console.log("Привіт!");
sayHi();


/* ----- Круто!!! А можу я щось передавати окрім значень?
Так - callback function (функції зворотного виклику)!

Колбек в JavaScript - це функція, яка передається як аргумент до іншої функції.
Ця функція потім викликається (активується) в пізніший момент часу, часто асинхронно (після завершення деякого іншого завдання).
Це робить код більш модульним і гнучким.
*/

// уявимо таку ситуацію, ми хочемо поділити логіку виводу та математики
function myDisplayer(sentence) { // функція виводу в консоль
    console.log("Результат - " + sentence);
}

function myCalculator(num1, num2) { // функція додавання двох чисел
    let sum = num1 + num2;
    return sum;
}

let result = myCalculator(5, 4); // викликаємо функцію де відбувається обчислення
myDisplayer(result); // викликаємо функцію котра виводить результат


// чи можна зробити так
function myDisplayer(sentence) {
    console.log("Результат - " + sentence);
}

function myCalculator(num1, num2) {
    let sum = num1 + num2;
    myDisplayer(sum); // всередині функції  викликаємо функцію котра буде виводити у консоль результат
}

myCalculator(5, 4); // викликаємо функцію котра вираховує результат

// давайте переробимо под колбек

function myDisplayer(sentence) {
    console.log("Результат - " + sentence);
}

function myCalculator(num1, num2, myCallback) {
    let sum = num1 + num2;
    myCallback(sum);
}

myCalculator(5, 4, myDisplayer); //як бачите, тут визов третьго параметра є функцією, це і є колбеком
/*----------------------------

Developer Mozilla:
https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for

W3school:
https://www.w3schools.com/js/js_loop_for.asp
https://www.w3schools.com/js/js_loop_while.asp
https://www.w3schools.com/js/js_function_definition.asp
https://www.w3schools.com/js/js_functions.asp
https://www.w3schools.com/js/js_arrow_function.asp

JavaScript Info:
https://uk.javascript.info/while-for
https://uk.javascript.info/function-basics
https://uk.javascript.info/arrow-functions-basics

https://codeburst.io/all-about-javascript-functions-in-1-article-49bfd94b31ab
*/